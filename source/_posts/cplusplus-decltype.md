---
title: C++系列：decltype 类型说明符
date: 2024-07-30 17:54:59
updated: 2024-07-30 17:54:59
tags:
- c++ 语言
- 类型说明符
- decltype
categories: 
- 笔记
---

这篇文章介绍 decltype 类型说明符。

<!-- more -->

## 概述

有时会遇到这种情况：希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。为了满足这一要求，C++11 新标准引入了第二种类型说明符 decltype, 它的作用是选择并返回操作数的类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值：
```c++
decltype(f{}) sum = x; // sum的类型就是函数f的返回类型。
```

编译器并不实际调用函数f,而是使用当调用发生时 f 的返回值类型作为sum的类型。换句话说，编译器为 sum 指定的类型是什么呢？就是假如 f 被调用的话将会返回的那个类型。

decltype 处理顶层 const 和引用的方式与 auto 有些不同。如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内）：
```c++
const int ci = 0, &cj = ci; 
decltype(ci) x = 0;  // x 的类型是 const int;
decltype(cj) y = x;  // y 的类型是 const int&，y 绑定到变量 x
decltype(cj) z;      // 错误：z 是一个引用，必须初始化
```

因为 cj 是一个引用，decltype(cj) 的结果就是引用类型，因此作为引用的 z 必须被初始化。

**decltype 和引用**
如果 decltype 使用的表达式不是一个变量，则 decltype 返回表达式结果对应的类型。有些表达式会返回一个引用类型，一般来说当月这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值：
```c++
// decltype 的结果可以是引用类型
int i = 42, *p = &i, &r = i;
decltye(r + 0) b;     // 正确：加法的结果就是 int，因此 b 是一个（未初始化的）int
decltye(*p) c;        // 错误：c 是 int& ,必须初始化
```

因为 r 是一个引用，因此 decltype(r) 的结果是引用类型。如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，如 r+0, 显然这个表达式的结果将是一个具体值而非一个引用。
另外一方面，如果表达式的内容是解引用操作，则 decltype 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，decltype(*p) 的结果类型就是 int&,而非int。
decltype 和 auto 的另一处重要区别是，decltype 的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于 decltype 所用的表达来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。如果 decltype 使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 decltype 就会得到引用类型：
```c++
// decltype 的表达式如果是加上了括号的变量，如果将是引用
decltype((i)) d;      // 错误：d 是int&，必须初始化
decltype(i) e;        // 正确：e 一个（未初始化的）int
```
